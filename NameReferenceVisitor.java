package astparser.visitor;

import java.util.*;
import org.eclipse.jdt.core.dom.*;

/**
 * NameReferenceVisitor visits ASTNode, find all SimpleName nodes that match
 * the interest keys. That is, the visitor finds all nodes that are references
 * of the input keys. The input keys can be type keys, variable keys or 
 * any possible SimpleName keys.
 * The visitor will return parent nodes of the SimpleNode that it found. 
 * The result is returned as a hashmap where the map keys are the input keys.
 */

public class NameReferenceVisitor extends ASTVisitor {
	private HashMap<String, ReferenceInfo> references;
	
	/**
	 * Constructor that set the input keys generated by Eclipse JDT
	 * An example of type keys: the type "android.view.MenuItem" has key
	 * "Landroid/view/MenuItem;"
	 * An example of local variable keys. An android.view.View field name
	 * aButton, declared in type astparser.tests.TypeReference has key
	 * "Lastparser/tests/TypeReference;.aButton)Landroid/view/View;"
	 */
	public NameReferenceVisitor(String[] keys) {			

		references = new HashMap<String, ReferenceInfo>(keys.length);

		for (String key : keys) {
			references.put(key, new ReferenceInfo(key));
		}
	}

	@Override 
	public boolean visit(SimpleName node) {
		IBinding binding = node.resolveBinding();
		String key;
		if (binding != null){
			key = binding.getKey();
			if  (references.containsKey(key)) {
				ASTNode parent = node.getParent();
				if (parent != null)
					references.get(key).add(parent);
				else
					references.get(key).add(node);
			}
		}
		return false;
	}

	public List<ReferenceInfo> getNonEmpty () {
		Set<String> keys = references.keySet();
		List<ReferenceInfo> refs = new ArrayList<ReferenceInfo>();
		for (String key : keys) {
			ReferenceInfo ref = references.get(key);
			if (!ref.isEmpty())
				refs.add(ref);
		}
		return refs;
	}
}